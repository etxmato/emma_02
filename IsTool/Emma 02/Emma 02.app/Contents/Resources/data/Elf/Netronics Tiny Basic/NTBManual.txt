





                           NETRONICS

                      TINY BASIC User Manual

      COPYRIGHT 1978
      BY NETRONICS RESEARCH AND DEVELOPMENT LTD.
      RT. 202 NEW MILFORD, CT 06776

ALL RIGHTS RESERVED

                                              REVISION A

                    ADDENDUM FOR EARLY 4K BOARD

The early production manual for the 4K Board indicated that the original 256 bytes had to be placed below the 4K being added. 
This was an error. The first 4K board can be addressed at location
0000. The original 256 bytes will simply automatically relocate at
the memory location above the 4K board being added. if a second
4K board is added the original 256 bytes will again automatically relocate.

If the transistor Q1 supplied was a 2N5232, please drop a note to the factory requesting a free 2N4384.

Please accept our apologies for any inconvenience this may have caused.

       NETRONICS RESEARCH & DEVELOPMENT LIMITED


      TINY BASIC was conceived by the dragons at the People's
Computer Company (PCC), a non-profit corporation in Menlo Park CA.
and its implementation defined by Dennis Allison and others in the
PCC newspaper and an offshoot newsletter.  The implementation of this
program follows the philosophy defined there.  The reader is referred
to PCC v.4 Nos 1-3 for a discussion of the inner workings of this
software.

Netronics TINY BASIC is supplied on a cassette ready to load into your
ELF II.  It exactly fills the first 4k of memory, so you should load it 
with the monitor commands.

    04, 00, 00, 0F, FF

After it is loaded, simply reset your computer and run.

TINY BASIC has special I/O routines to interface with a ASCII keyboard and the 1861 video interface on your ELF II, or if you prefer, it may communicate through an RS-232C or 20MA current-loop circuit to an
ordinary terminal.  It is not necessary to reprogram TINY BASIC to
select either of these I/O modes.  Just start typing on your ASCII keyboard and TINY will take all future input from the keyboard and send
all output to the video display. Or type a carriage return on your terminal, and TINY will look to the terminal for all input and output.
There is no Baud rate to adjust, because TINY measures the timing in
the first carriage return and transmits and receives at that rate. If
your terminal is half-duplex only, you should type a linefeed instead of a carriage return so that TINY BASIC will not try to echo your typing.

STATEMENTS

      TINY BASIC is a subset of Dartmouth BASIC, with a few
extensions to adapt it to the microcomputer environment.  Appendix B
contains a definition of the language; the discussion here is
intended to enable you to use it.  When TINY issues a line prompt (a
colon on the left margin) you may type in a statement with or without
a line number.  If the line number is included, the entire line is
inserted into the user program space in line number sequence, without
further analysis.  Any previously existing line with the same line
number is deleted or replaced by the new line.  If the new line
consists of a line number only, it is considered a deletion, and
nothing is inserted.  Blanks are not significant to TINY, so blanks
imbedded in the line number are ignored; however, after the first
non-blank, non-numeric character in the line, all blanks are
preserved in memory.

The following are valid lines with line numbers!

      123 PRINT "HELLO"
      456    G O T O 1 2 3
      7 8 9 PRINT "THIS IS LINE # 789"
      123
      32767 PRINT "THIS IS THE LARGEST LINE #"
      1PRINT"THIS, IS THE SMALLEST LINE #"
      10000 TINY BASIC DOES NOT CHECK
      10001 FOR EXECUTABLE STATEMENTS ON INSERTION.

0 Is not a valid line number.

If the input line does not begin with a line number it is executed directly, and must consist of one of the following statement types:

      LET             GOTO            REM         OUT        POKE
      IF...THEN       GOSUB           CLEAR       PLOT
      INPUT           RETURN          LIST        SAVE
      PRINT           END             RUN         LOAD

      These statement types are discussed in more detail in the pages
to follow.
      Note that all 17 statement types may be used in either the
Direct Execution mode (without a line number) or in a program
sequence (with a line number).  Two of the statements (INPUT and RUN)
behave slightly differently in these two operating modes, but
otherwise each statement works the same in Direct Execution as within
a program.  Obviously there is not much point in including such
statements as RUN or CLEAR in a program, but they are valid.
Similarly, a GOSUB statement executed directly, though valid, is
likely to result in an error stop when the corresponding RETURN
statement is executed.


EXPRESSIONS

      Many of these statement types involve the use of EXPRESSIONS.
An Expression is the combination of one or more NUMBERS or VARIABLES,
joined by OPERATORS, and possibly grouped by Parentheses.  There are
four Operators:

      +   addition
      -   subtraction
      *   multiplication
      /   division

These are hierarchical, so that in an expression without parentheses,
multiplication and division are performed before addition and
subtraction.  Similarly, sub-expressions within parentheses are
evaluated first.  Otherwise evaluation proceeds from left to right.
Unary operators (+ and -) are allowed in front of an expression to
denote its sign.

      A Number is any sequence of decimal digits (0, 1, 2, ... 9),
denoting the decimal number so represented.  Blanks have no
significance and may be imbedded within the number for readability if
desired, but commas are not allowed.  All numbers are evaluated as
16-bit signed numbers, so numbers with five or more digits are
truncated modulo 65536, with values greater than 32767 being
considered negative.  The following are some valid numbers (note
that the last two are equivalent to the first two in TINY):

      0
      100
      10 000
      1 2 3 4
      32767
      65536
      65 636

Note that because TINY BASIC is tiny, you cannot have any numbers
greater than 32767. If you type in a larger number, TINY will convert
the whole number to binary, but then throw away everything except
the last 16-bits.  For example, if you type in 65636 (as in the example), TINY BASIC will convert it to a binary number, divide by 65536, and keep the remainder (which in this case is 100). Numbers which are greater than 32767 but less than 65536 will be considered to be negative. it is the same as if you subtracted 65536 from the number.  Such a number is, for example, 65436, it will actually print out -100 on your console/terminal.

Similarly, when TINY BASIC does aritmetic, each result (including intermediate answers) is effectively divided by 65536 and only the
remainder is kept.

A Variable is any Capital letter (A, B, ... Z). This variable
is assigned a fixed location in memory (two bytes, the address of
which is twice the ASCII representation of the variable name).  It
may assume any value in the range, -32768 to +32767, as assigned to
it by a LET or INPUT statement.

The following are some examples of valid expressions:

      A
      123
      1+2-3
      B-14*C
      (A+B)/(C+D)
      -128/(-32768+(I*1))
      (((((Q)))))

All expressions are evaluated as integers modulo 65536.  Thus
an expression such as

      N / P * P

may not evaluate to the same value as (N), and in fact this may be
put to use to determine if a variable is an exact multiple of some
number.  TINY BASIC also makes no attempt to discover arithmetic
overflow conditions, except in the case of an attempt to divide by
zero (which results in an error stop).  Thus all of the following
expressions evaluate to the same value:

      -4096
      15*4096
      32768/8
      30720+30720

TINY BASIC allows four intrinsic functions. 

Either of these functions may be used anywhere an (expression) is
appropriate.


FUNCTIONS

      PEEK (address) 

This function has as its value, the contents of the memory byte at the
specified address.

      INP (port)

This function has as its value, the data byte at the specified input port. The input port number should be an expression or number in the
range 1-7; values outside this range will normally result in an error
stop. 1-7 correspond to the N9 to NF instruction.

Actually, TINY BASIC assumes that INP(0) is valid, even though there
is no port 0 on your elf II.

This function may be used to read the hex keypad on your basic ELF 
(by INP(4)).

      USR (address)
      USR (address,R8)
      USR (address,R8,RA)

      This function is actually a machine-language subroutine call to
the address in the first argument.  If the second argument is
included the CPU register R8 contains that value on entry to the
subroutine. If the third argument is included, it is placed in RA. The accumulators contains a copy of the low byte of the last argument. The High byte of RA and the accumulator (as the low byte) form the 16-bit value of the function on return. All three arguments are evaluated as normal expressions.

It should be noted that machine language subroutine addresses are 16-bit Binary numbers.  TINY BASIC evaluates all expressions to 16-bit binary numbers, so any valid expression may be used to define a subroutine address.  However, most addresses are expressed in hexadecimal whereas TINY BASIC only accepts numerical constants in decimal.  Thus to jump to a subroutine at hex address 40AF, you must code USR(16559). Hex address FFB5 is similarly 65461 in decimal,though the equivalent (-75) may be easier to use. Your machine language subroutine should not alter the contents of R2, R4-R7, R9,RB, or RE. P=3 and X=2 when the subroutine is 
entered, and the subroutine should exit by a SEP R5 (HEX D5) instruction.
TINY BASIC uses the "Standard Call and Return Technique" described on Page 61 of MPM-201A (available from Netronics or RCA), so your subroutine may call other machine language subroutines without trying up other registers.

      RND (range)

This function has as its value, a positive pseudo-random number
between zero and range-1, inclusive.  If the range argument is zero
an error stop results.

STATEMENT TYPES

      PRINT print-list
      PR print-list

This statement prints on the console/terminal the values of the
expressions and/or the contents of the strings in the print-list.
The print-list has the general form,

      item,item...    or      item;item...

The items may be expressions or alphanumeric strings enclosed in
quotation marks (e.g. "STRING").  Expressions are evaluated and
printed as signed numbers; strings are printed as they occur in the
PRINT statement.  When the items are separated by commas the printed
values are justified in columns of 8 characters wide; when semicolons
are used there is no separation between the printed items. Thus,

      PRINT 1,2,3

prints as

      1       2       3

and

      PRINT 1;2;3

prints as

      123

Commas and semicolons, strings and expressions may be mixed in one
PRINT statement at will.

If a PRINT statement ends with a comma or semicolon TINY BASIC
will not terminate the output line so that several PRINT statements
may print on the same output line, or an output message may be
printed on the same line as an input request (see INPUT).  When the
PRINT statement does not end with a comma or semicolon the output is
terminated with a carriage return and linefeed (with their associated
pad characters).  To aid in preparing data tapes for input to other
programs, a colon at the end of a print-list will output an "X-OFF"
control character just before the Carriage Return.

Although the PRINT statement generates the output immediately
while scanning the statement line, output lines are limited to 125
characters, with excess suppressed.

While the Break key will not interrupt a PRINT statement in
progress, the Break condition will take effect at the end of the
current PRINT statement.

The following are some examples of valid PRINT statements:

      PRINT "A=";A,"B+C=";B+C
      PR                        (one blank line)
      PRI                       (prints the value of I)

In order to run faster, TINY BASIC turns off the video display
while it is computing. Each time a PRINT statement ends a line
(i.e. a PRINT which does not end with a comma or semi-colon),
TINY will turn on the display for about 1/4 second to give you a chance to see what the program has typed so far. Then, or any time the program is actually putting charaters on the screen, you may hold the display on 
for extended viewing by pressing the Input ("I") key on the basic ELF. Of course TINY stops computing when you do this. This key has no effect if TINY is not printing anything, or if your effective print line is longer than 125 charaters.

      INPUT input-list

This statement checks to see if the current input line is
exhausted.  If it is, a question mark is prompted with an X-ON
control character, and a new line is read in.  Then or otherwise, the
input line is scanned for an expression which is evaluated.  The
value thus derived is stored in the first variable in the input-list.
If there are more variables in the input-list the process is
repeated.  In an executing program, several values may be input on a
single request by separating them with commas.  If these values are
not used up in the current INPUT statement they are saved for
subsequent INPUT statements.  The question mark is prompted only when
a new line of input values is required.  Note that each line of input
values must be terminated by a carriage return.  Since expressions
may be used as input values, any letter in the input line will be
interpreted as the value of that variable.  Thus if a program sets
the value of A to 1, B to 2, and C to 3, and the following statement
occurs during execution:

      INPUT X,Y,Z
and the user types in
      A,C,B
the values entered into X, Y, and Z will be 1, 3, and 2,
respectively, just as if the numbers had been typed in.  Note also
that blanks on the input line are ignored by TINY, and the commas are
required only for separation in cases of ambiguity.  In the example
above
      ACB
could have been typed in with the same results.  However an input,
line typed in as
      +1  -3  +6   0
will be interpreted by TINY as a single value (=58) without commas
for separators.  

      Due to the way TINY BASIC buffers its input lines, the INPUT
statement cannot be directly executed for more than one variable at a
time, and if the following statement is typed in without a line
number,

      INPUT A,B,C

the value of B will be copied to A, and only one value (for C) will
be requested from the console/terminal.  Similarly, the statement,

      INPUT X,1,Y,2,Z,3

will execute directly (loading X, Y, and Z with the values 1, 2, and
3), requesting no input, but with a line number in a program this
statement will produce an error stop after requesting one value.

If the number of expressions in the input line does not match
the number of variables in the INPUT statement, the excess input is
saved for the next INPUT statement, or another prompt is issued for
more data. The user should note that misalignment in these
circumstances may result in incorrect program execution (the wrong
data to the wrong variables). If this is suspected, data entry may be
typed in one value at a time to observe its synchronization with
PRINT statements in the program.

There is no defined escape from an input request, but if an
invalid expression is typed (such as a period or a pair of commas) an
invalid expression error stop will occur.

Because Tiny Basic does not allow arrays, about the only way to
process large volumes of data is through paper tape files.  Each
input request prompt consists of a question mark followed by an X-ON
(ASCII DC1) control character to turn on an automatic paper tape
reader on the Teletype (if it is ready).  A paper tape may be
prepared in advance with data separated by commas, and an X-OFF
(ASCII DC3 or Control-S) control character preceding the CR (a
Teletype will generally read at least one more character after the
X-OFF).  In this way the tape will feed one line at a time, as
requested by the succession of INPUT statements.  This tape may also
be prepared from a previous program output (see the PRINT
statement).

      LET var = expression
      var = expression

This statement assigns the value of the expression to the
variable (var).  The long form of this statement (i.e. with the
keyword LET) executes slightly faster than the short form.  The
following are valid LET statements:

      LET A = B+C
      I = 0
      LET Q = RND (RND(33)+5)


GOTO expression

The GOTO statement permits changes in the sequence of program
execution.  Normally programs are executed in the numerical sequence
of the program line numbers, but the next statement to be executed
after a GOTO has the line number derived by the evaluation of the
expression in the GOTO statement.  Note that this permits you to
compute the line number of the next statement on the basis of program
parameters during program execution.  An error stop occurs if the
evaluation of the expression results in a number for which there is
no line.  If a GOTO statement is executed directly, it has the same
effect as if it were the first line of a program, and the RUN
statement were typed in, that is, program execution begins from that
line number, even though it may not be the first in the program.
Thus a program may be continued where it left off after correcting
the cause of an error stop.  The following are valid GOTO
statements:
      GOTO 100
      GO TO 200+I*10
      G 0 T 0 X

GOSUB expression

The GOSUB statement is like the GOTO statement, except that TINY
remembers the line number of the GOSUB statement, so that the next
occurrence of a RETURN statement will result in execution proceeding
from the statement following the GOSUB.  Subroutines called by GOSUB
statements may be nested to any depth, limited only by the amount of
user program memory remaining.  Note that a GOSUB directly executed
may result in an error stop at the corresponding RETURN.  The
following are some examples of valid GOSUB statements:
      GOSUB 100
      GO SUB 200+I*10

RETURN

The RETURN statement transfers execution control to the line
following the most recent unRETURNed GOSUB.  If there is no matching
GOSUB an error stop occurs.

IF expression rel expression THEN statement
IF expression rel expression statement

The IF statement compares two expressions according to one of
six relational operators.  If the relationship is True, the statement
is executed; if False, the associated statement is skipped.  The six
relational operators are:
      =               equality
      <               less than
      >               greater than
      <=              less or equal (not greater)
      >=              greater or equal (not less)
      <>, ><          not equal (greater or less)

The statement may be any valid TINY BASIC statement (including
another IF statement).  The following are valid IF statements:

      IF I>25 THEN PRINT "ERROR"
      IF N/P*P=N GOTO 100
      IF 1=2 Then this is nonsense
      IF RND (100) > 50 THEN IF I <> J INPUT Q,R

END

The END statement must be the last executable statement in a
program.  Failure to include an END statement will result in an error
stop after the last line of the program is executed.  The END
statement may be used to terminate a program at any time, and there
may be as many END statements in a program as needed.  The END
statement also clears out any saved GOSUB line numbers remaining, and
may be used for that purpose in the direct execution mode.

REM comments

The REM statement permits comments to be interspersed in the
program.  Its execution has no effect on program operation, except
for the time taken.

CLEAR

The CLEAR statement formats the user program space, deleting
any previous programs.  If included in a program (i.e. with a line
number) the program becomes suicidal when the statement is executed,
although no error results.  If the Warm Start is used to initialize
the interpreter, this must be the first command given.

     RUN
     RUN,expression-list

The RUN statement is used to begin program execution at the
first (lowest) line number.  If the RUN statement is directly
executed, it may be followed by a comma, followed by values to be
input when the program executes an INPUT statement.

If the RUN statement is included in a program with a line
number, its execution works like a GO TO first statement of the
program.

      LIST
      LIST expression
      LIST expression,expression

The LIST statement causes part or all of the user program to be
listed.  If no parameters are given, the whole program is listed.  A
single expression parameter in evaluated to a line number which, if
it exists, is listed.  If both expression parameters are given, all
of the lines with line numbers between the two values (inclusive) are
listed.  If the last expression in the LIST statement evaluates to a
number for which there is no line, the next line above that number
which does exist (if any) is listed as the last line.  Zero is not a
valid line number, and an error stop will occur if one of the
expressions evaluates to zero.  A LIST statement may be included as
part of the program, which may be used for printing large text
strings such as instructions to the operator.  A listing may be
terminated by the Break key.

If the terminal punch (or cassette recorder) is turned on for a
LIST operation, the tape may be saved to reload the program into TINY
at a later time.
The following are valid LIST statements:

      LIST
      LIST 75+25            (lists line 100)
      LIST 100,200
      LIST 500,400          (lists nothing)

PLOT

      PLOT char
      PLOT vertical, horizontal
      PLOT vertical, horizontal, char

This statement positions the cursor of the video display to any place on the screen, and/or plots a character at that point. If there are two or more arguments, the first argument defines the vertical position, and should evaluate to a number in the range 0-41, where 0 refers to the top of the screen and 41 to the bottom. The second argument defines the horizontal position, and should evaluate to a number in the range 0-63, wheree 0 refers to the left margin and 63 refers to the right margin. If there are an odd number of arguments, the last argument is evaluated to a
number which is converted to an ASCII character and printed at the (now current) cursor position.

If either the horizontal or vertical position argument falls outside the display area an error stop occurs. For the character to be displayed, however, only the low seven bits are considered.  

There are four special characters values which will help in making plots with this statement:

0 (NUL) This erases (sets to black) the dot at the cursor position. The cursor position is not changed.
1 (SOH) This turns on (sets to white) the dot at the cursor position without moving the cursor.
10 (LF) This moves the cursor down six steps and turns on the display for 1/4 second. If the cursor was in the bottom six vertical steps, the whole screen is scrolled up so that the new cursor position is on the bottom line of the screen.
12 (FF) This character erases the entire screen and places the cursor at the left margin of the top line (equivalent to PLOT 0,0)

Note that the cursor is normally on the row just below most ASCII characters printed in that position, so when the cursor is above row 5 some or all of the characters printed will be cut off at the top.

If you are using an ordinary terminal instead if the video display, the horizontal and vertical position arguments will have no effect and the output character argument will cause that character to be sent to your terminal.

Examples:

     PLOT 0,0         Move the cursor to top left corner
     PLOT 12          Erase the screen
     PLOT 41,63,1     Put a white dot in the bottom right corner
     PLOT X,Y,65      Put the letter "A" in the position determined by X and Y. 

OUT  PORT,DATA

This command outputs to the specified port the low eight bits of the second argument. The port number must be in the range 0-7 (though of course there is no port 0) or an error stop results.
The following are valid OUT commands:

     OUT 4, H  (Output value of H on hex display)
     OUT 1, 0  (Turn off TV)

POKE ADDRESS,DATA

This command stores the byte in the second argument into the memory address specified by the first argument.  Caution: careless use of this command can cause TINY BASIC to operate improperly; be sure you are not  pokeing inside TINY (locations 00B6-0DAF), in the TINY BASIC reserved data areas (0008-002F) or in the stack (the last hundred or so bytes of memory). You should also avoid poking inside your own program unless you know what you are doing.

Notice that any addresses you give the POKE command must be in decimal, so if you want to POKE location 0080 (the random number used) you must convert that address to 128 (decimal) for use in the POKE command.

Examples:

     POKE 3,0         Store zero in 0003
     POKE 3,1+PEEK(3) Add 1 to contents of 0003

SAVE, LOAD

These two commands are used for saving a program on cassette and reloading it at a later time.  When you execute a SAVE command,
TINY will respond with

TURN ON RECORD
HIT KEY

You should, at this time, prepare the cassette recorder to record data, turn it on, then press some key on your keyboard. The screen will blank while data is being recorded.

When the LOAD command is executed it goes immediately to the cassette data input and waits for valid data to come. You should, at this time, put your cassette recorder in playback mode and turn it on. As soon as data begins to arrive it will be displayed on the hex display of your basic ELF. Note that this is the actual data being displayed, not the addresses as when the Netronics monitor is being used to load machine language programs. When load is complete a 00 shows on the hex display, and TINY will return to the command mode with a colon prompt. This is true regardless of whether the LOAD command was issued from inside a running program or not.

If there is an error in reading the tape the Load operation is aborted, memory "cleared" (same as CLEAR command) and the message "TAPE ERROR" is displayed on your console/terminal.

The TINY BASIC commands to LOAD and SAVE programs only operate with whole programs. In other words, the SAVE command will save the whole program in memory: the LOAD command will read in whatever program is on the cassette and adjust the program size parameters to fit the loaded program. You cannot use these commands to collect several pieces into one program.

The data stored on the cassette is in the standard Netronics cassette format, using some of the cassette I/O routines in the Netronics monitor. These commands will not work correctly without the Netronics monitor! You do not need to tell TINY BASIC where or how much memory to save or load as with the monitor commands. The starting address is always the beginning of the user area, and the ending address is defined by the end of the program.

CAUTION: Do not attempt to load a program saved in a computer with a larger memory unless you are sure the program will fit in the smaller memory.

OPERATING NOTES

Aside from injudicious use of the POKE and USR or trying to LOAD a program made on a larger computer, it is virtually not possible to crash TINY BASIC. If you try to type in a command that TINY does not recognize, it will simply issue an error message and come back for another command. If some statement in your program does not make sense to TINY, the program will stop running with an error number which will help you to find the problem. If you try to type in more program than you have memory for, TINY will simply refuse to accept the excess. If you try to type in a line that is too long, TINY will also ignore the excess; note that in this case your line may not be what you expected, and other error messages may result. Sometimes TINY will accept a long input line then discover that it has insufficient memory to process it.  This might happen when it tries to evaluate a complicated expression. you will get an error message, but all that is lost is the contents of that input line.

All error messages come in the following form:

      !eee AT nnnn
where eee refers to the error number, and nnnn refers to the line number of the program where the error occured. If the error did not occur in the running program, the message is abbreviated to :

      !eee
The significance of each likely error number is listed in Appendix A.

When you get an error message from a running program, it may be possible to correct the problem and resume from where you left off. For example, if you misspell a statement name or get your expression jumbled, TINY will complain. You may, at this time, retype the offending line or make any other corrections that seem appropriate, then continue by typing:

     GOTO nnnn
where nnnn is the line number that caused the error, or some other line number, where you wish to resume.

One kind of error that TINY BASIC does not recognize is when your program gets stuck in an "infinite loop", repeating the same statements over and over. If you suspect that this is the case, you may cause the program to "break out" of its execution by typing any character on your keyboard or by pushing the Break key on your terminal (depending on which is active). TINY will stop immediately before executing the next statement and issue error number 0. This is not really an error, of course, but it works exactly the same way. In other words, you can look at your program variables, LIST parts of the program, or even make changes (such as adding extra PRINT statements) before continuing. If you decide not to continue, it is a good idea to type in END so TINY will not try to save all the unRETURNed GOSUBs.

When you are typing in a program line or data in response to an INPUT statement, you can "backspace" over erroneous characters by typing (RUBOUT or) underscore (shift-0) on some terminals). IF you back up over the start of the line a new prompt will be given. If you prefer, you may abort the whole line by typing ESCAPE. This displays on your screen as a cursor dot, then a new prompt is issued. The aborted line is ignored.

When you are LISTing a program on your video display it will probably go by faster than you can read it. You can hold it at any time by pressing the "input" key on your basic ELF. IF you want to abort the rest of a listing just type any character on your ASCII keyboard (or press BREAK on your terminal).  Of course, you can always LIST only the lines you want to see. You can hold or abort print out from your program in the same way.

SAMPLE PROGRAMS

The cassette tape which came with TINY BASIC on it also has two sample programs written in TINY to demonstrate the PLOT command and some of the other features of TINY. After you finish loading TINY BASIC, stop the cassette while you start up TINY. Then type in:
     LOAD
and turn the cassette back on. After a few seconds the hex display will flicker and TINY will come back for another command. Turn the cassette off again, and type

     V=20
     H=30
     RUN

The TV screen will begin flashing on and off and a little dot near the center will appear. This may or may not start to grow into a line, depending on the last key you pushed on the hex keyboard of your basic ELF.

This program is a picture-drawing program (granted, a little slow, but ideal for slow thinkers like me and your kids). The hex keypad is a sort of joystick, where the last key you pressed determines the direction that the dot will move, leaving a trail behind it. Perhaps after playing with it a little while you will want to stop it and LIST it; it is only eight or so lines and fits easily into a mimimum 4K ELF.  There is even room to make a (very) few changes. Try it. Can you figure out how it works?

If you have 8K or more, you will want to try the second program on the cassette (if you have less than 8K, don't bother; if you try to load it you will only clobber TINY BASIC).

This program plays Tic-tac-toe. There are a number of comments in the program listing to help you figure out how it works, and when you RUN it, it will tell you how to play against the computer. I did not intend so, but it turns out that the program can be beaten; it seems such a pity since it spends so much time thinking out each move. Oh, well, "Man over Machine".

ADVANCED PROGRAMMING TIPS

Sometimes you will find it convenient to go back to the Monitor (say to  code up a machine language subroutine to call from TINY). Rather than resetting the computer, you can get there simply by referring to "USR (6)". Since This is a function, not a command, you must use it in an expression, such as:

   I=USR(6)
or 
   PRINT USR(6)
or 
   IF USR(6)
NOTE: If you are using a EIA terminal use:
   I=USR(12,3)
or
   PRINT USR(12,3)
or 
   IF USR (12,3)
(Valid only when not using ASCII+TV)

Notice that since this function call never returns, it does not matter much how it is called. If you expect to use the monitor for much, you will want to change the first byte in memory to "C8" so that reset-run jumps to the monitor rather than TINY. You can then start up TINY BASIC from the monitor by the following hex command sequence:

   00,01,00

This, of course, initializes TINY for a new program, clears the video display, and so on. If you wont to save a previous TINY BASIC program in memory, you may use the "Warm Start":

   00,01,03

The Warm Start may also sometimes be used if TINY crashes due to an error in a USR function call. If you accidentally POKE holes in the stack or TINY BASIC, there might be enough left to save your program on cassette before re-loading TINY; the Warm Start is a "fail-soft" alternative to retyping. CAUTION: DO NOT try to use the Warm Start before TINY has had a chance to initialize its memory space (by the "Cold Start", 0100).

In keeping with the "small is good" philosopy, TINY BASIC employs
the two level interpreter appoach (with its consequent speed cost).

TINY BASIC is designed to be I/O independent, with all input and output funneled through three jumps placed near the beginning of the program.

Location 0106 is a JMP to a subroutine to read one ASCII character from the console/terminal. Location 0109 is a JMP to a subroutine to type or display one ASCII character on the console/terminal. In both cases the character is in the accumulator. It is assumed that the character input routine will simultaneously display each character as it is input; if this is not the case, the LBR instruction in location 0106 may be converted to a SEP4, so that each character input flows through the output subroutine (which in this case must preserve D) before being fed to TINY. Users with terminals using Baudot or some other non-ASCII code should perform the character conversion in the Input and Output subroutines. Each input prompt by TINY is followed by an "X-ON" character (ASCII DC1) with the sign bit set to 1 (all other characters except rubout are output with the sign bit set to 0) so these are also readily detected.

A third subroutine provided by you is optional, and gives TINY 2 a means to test for the BREAK condition in your system. Simply replace locations 010C-010E with a LBR to your subroutine, which returns with the break condition recorded in the Carry flag (1 = BREAK, 0 = no BREAK). The Break condition is used to interrupt program execution, or to prematurely terminate a LIST operation. Tiny responds to the Break condition any time in the LIST, or just before examining the next statement in program execution. If a LIST statement included within a program is aborted by the Break condition, the Break condition must be held over to the next statement fetch (or repeated) to stop program execution also. 

All input to Tiny is buffered in a 72 character line, terminated by a Carriage Return ("CR"). Excess characters are ignored, as signaled by ringing the console/terminal bell. When the CR is typed in, Tiny will echo it with a Linefeed, then proceed to process the information in the line. If a typing error occurs during the input of either a program line or data for an INPUT statement, the erroneous characters may be deleted by "backspacing" over them and retyping. If the entire line is in error, it may be canceled (and thus ignored) by typing the "Cancel" key. The Backspace code is located near the beginning of the program (location 010F), and is set by default to "left-arrow" or ASCII Underline (shift-O on your Teletype). To change this to the ASCII Standard Backspace code (or anything else you choose), the contents of location 010F may be changed to the desired code. Similarly the Cancel code is located at memory address 0110, and is set by default to the ASCII Cancel code (Control-X). Four characters which may not be used for line edits (Backspace or Cancel) are DC3 (hex 13), LF (0A), NUL (00), and DEL (FF). These codes are trapped by the TINY BASIC input routines before line edits are tested. 

When Tiny ends a line (either input or output), it types a CR, two pad characters, a Linefeed, and one more pad character. The pad character used is defined by the sign bit in location 0111, and is set by default to the "Rubout" or Delete code (hex FF; Location 0111 Bit 7 = 1) to minimize synchronization loss for bit-banger I/O routines. The pad character may be changed to a Null (hex 00) by setting the sign of location 0111 to 0. The remainder of this byte defines the number of Pad characters between the CR and linefeed. More than two pad characters may be required if large user programs are to be loaded from tape (see comments on Tape Mode, below). 

TINY BASIC has a provision for suppressing output (in particular line prompts) when using paper tape for loading a program or inputting data. This is activated by the occurrence of a Linefeed in the input stream (note that the user normally has no cause to type a Linefeed since it is echoed in response to each CR), and disables all output (including program output) until the tape mode is deactivated. This is especially useful in half-duplex I/O systems since any output would interfere with incoming tape data. 

                    A P P E N D I X   A

                   ERROR MESSAGE SUMMARY


0     Break during execution
8     Memory overflow; line not inserted
9     Line number 0 not allowed
13    RUN with no program in memory
18    LET is missing a variable name
20    LET is missing an =
23    Improper syntax in LET
25    LET is not followed by END
34    Improper syntax in GOTO
37    No line to GO TO
39    Misspelled GOTO
40,41 Misspelled GOSUB
46    GOSUB subroutine does not exist
59    PRINT not followed by END
62    Missing close quote in PRINT string
73    Colon in PRINT is not at end of statement
75    PRINT not followed by END
95    IF not followed by END
104   INPUT syntax bad - expects variable name
123   INPUT syntax bad - expects comma
124   INPUT not followed by END
132   RETURN syntax bad
133   RETURN has no matching GOSUB
134   GOSUB not followed by END
139   END syntax bad
158   LIST syntax error - too many arguments
166   Can't LIST line number 0
245   Syntax error in PLOT
257   Syntax error in PLOT
284   Syntax error in POKE or OUT
293   SAVE misspelled
354   LOAD misspelled
394   REM not followed by END
395   Missing statement type keyword
397   Misspelled statement type keyword
403   Memory overflow: too many GOSUB's ...
424      ... or expression too complex
434   Divide by 0
445   Expression too complex ...
446   ... using RND ...
449   ... in direct evaluation;
453   ... simplify the expression
471   RND (0) not allowed
495   USR expects ")" after arguments
560   Missing ")" in INP, or PEEK
558   Expression too complex
559   Syntax error in expression - expects value
560   Syntax error - expects ")"
616   Argument in INP, OUT, or PLOT too large
623   Argument in INP, OUT, or PLOT too small (i.e.<0)

Several other numbers may come out as errors; these usually mean memory overflowed, or the expression was too complex, or the input line is too long.

                     A P P E N D I X   B

               FORMAL DEFINITION OF TINY BASIC


line ::= number statement CR
         statement CR
statement ::= PRINT printlist
              PR printlist
              INPUT varlist
              LET var = expression
              var = expression
              GOTO expression
              GOSUB expression
              RETURN
              IF expression relop expression THEN statement
              IF expression relop expression statement
              REM commentstring
              CLEAR
              RUN
              RUN exprlist
              LIST
              LIST exprlist
              PLOT exprlist
              OUT exprlist
              LOAD
              SAVE
              POKE exprlist
printlist ::=
              printitem
              printitem :
              printitem separator printlist
printitem ::= expression
              "characterstring"
varlist ::= var
            var , varlist
exprlist ::= expression
             expression , exprlist
expression ::= unsignedexpr
               + unsignedexpr
               - unsignedexpr
unsignedexpr ::= term
                 term + unsignedexpr
                 term - unsignedexpr
term ::= factor
         factor * term
         factor / term
factor ::= var
           number
           ( expression )
           function
function ::= RND ( expression )
             USR ( exprlist )
             INP ( expression )
             PEEK ( expression )
number ::= digit
           digit number
separator ::= , ! ;
var ::= A ! B ! ... ! Y ! Z
digit ::= 0 ! 1 2 ! ... ! 9
relop ::= < ! > ! = ! <= ! >= ! <> ! ><

                         A P P E N D I X   C

LOW MEMORY MAP


LOCATION        SIGNIFICANCE
--------        ------------

0000-0007       Not used TINY
0008-001F       TINY BASIC temporaries
0020-0021       Lowest address of user program space
0022-0023       Highest address of program space
0024-0025       Program end + stack reserve
0026-0027       Top of GOSUB stack
0028-002F       Interpreter parameters
0030-007F       Input line buffer & Computation stack
0080-0081       Random Number Generator workspace
0082-0083       Variable "A"
0084-0085       Variable "B"
...             ...
00B4-00B5       Variable "Z"
00B6-00FF       TINY BASIC (I/O Routines)
0100            Cold Start entry point (6800)
0103            Warm Start entry point
0106-0108       LBR (or SEP4) to character input
0109-010B       LBR to character output
010C-010E       LBR to Break test
010F            Backspace code
0110            Line Cancel code
0111            Pad character
0112            Tape Mode Enable flag (hex 80 = enabled)
0113            Spare stack size
0DB0-0F3F       Video display buffer
0F40            Beginning of User program

